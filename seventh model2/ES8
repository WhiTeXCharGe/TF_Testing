# employee_schedule.py
# Reads EnvConfig.yaml + Schedule.yaml, builds the problem entirely from them,
# Pass 1 builds fixed crew blocks (days Ã— heads) per task window (ALL 8 HOURS/DAY),
# Pass 2 uses Timefold to assign employees to those fixed seats (one var per seat),
# prints hard-violation audits, and OVERWRITES Schedule.yaml with assignment_list.

from dataclasses import dataclass, field
from datetime import date, datetime, timedelta
from typing import Annotated, Dict, List, Optional, Tuple
import yaml
from collections import defaultdict
import math
import time

from timefold.solver.domain import (
    planning_entity, planning_solution,
    PlanningId, PlanningVariable,
    PlanningEntityCollectionProperty, ProblemFactCollectionProperty,
    PlanningScore, ValueRangeProvider
)
from timefold.solver import SolverFactory
from timefold.solver.config import SolverConfig, TerminationConfig, ScoreDirectorFactoryConfig, Duration
from timefold.solver.score import (
    HardMediumSoftScore,
    ConstraintFactory, Constraint, Joiners,
    constraint_provider, ConstraintCollectors
)

from export_schedule import overwrite_schedule_with_assignments

# -------------------- Domain (facts) --------------------

@dataclass(frozen=True)
class DaySlot:
    id: int
    d: date

@dataclass(frozen=True)
class Employee:
    id: int           # internal numeric id for solver
    wid: str          # "w#": used for writing back
    name: str
    skills: Dict[str, int]

@dataclass(frozen=True)
class TaskWindow:
    module: str
    factory: str
    phase_id: str
    phase_num: int
    op_id: str
    start_day_id: int       # inclusive
    end_day_id: int         # inclusive
    allowed: List[int]      # allowed hours for this op (parsed but UNUSED in this simplified run)
    min_heads: int
    max_heads: int
    workload_days: int      # from Schedule.yaml

# -------------------- Pass 1: crew blocks (ALL 8 HOURS/DAY) --------------------

@dataclass(frozen=True)
class CrewBlock:
    module: str
    factory: str
    phase_id: str
    phase_num: int
    op_id: str
    start_day_id: int
    days: int               # consecutive days
    hours: int              # fixed hours/day (ALWAYS 8 in this simplified run)
    heads: int              # number of seats

def _plan_block_for_window_8h(w: TaskWindow, req_hours: int, earliest_start: int) -> Optional[CrewBlock]:
    """
    Build one block inside this window, assuming 8 hours/day (ignore hour options).
    Choose heads in [min,max] and smallest feasible days so heads*8*days >= req_hours
    and start_day >= earliest_start and (start_day + days - 1) <= window end.
    """
    start = max(w.start_day_id, int(earliest_start))
    window_len = max(0, w.end_day_id - start + 1)
    if window_len <= 0:
        return None

    best = None  # (days, heads, overfill)
    key_best = None
    H = 8  # fixed hours/day

    for heads in range(max(1, w.min_heads), max(1, w.max_heads) + 1):
        denom = heads * H
        if denom <= 0:
            continue
        days_needed = math.ceil(req_hours / float(denom))
        if days_needed <= 0 or days_needed > window_len:
            continue
        overfill = heads * H * days_needed - req_hours
        cand = (days_needed, heads, overfill)
        tie = (
            cand[0],   # minimize days
            cand[1],   # then smaller heads
            cand[2],   # then smaller overfill
        )
        if (best is None) or (tie < key_best):
            best = cand
            key_best = tie

    if best is None:
        # fallback: fit inside window with max heads and minimal days (still 8h)
        heads = max(1, w.max_heads)
        days = max(1, window_len)
    else:
        days, heads, _ = best

    return CrewBlock(
        module=w.module, factory=w.factory,
        phase_id=w.phase_id, phase_num=w.phase_num,
        op_id=w.op_id,
        start_day_id=start,
        days=days, hours=H, heads=heads
    )

# -------------------- Planning entity = one seat for whole block --------------------

@planning_entity
@dataclass
class CrewSeat:
    """
    One fixed seat for the whole block; Timefold assigns exactly one employee to it.
    There is no per-day planning variable, so swapping across days is impossible.
    """
    id: Annotated[int, PlanningId]

    # Facts (fixed)
    module: str
    factory: str
    phase_id: str
    phase_num: int
    op_id: str
    start_day_id: int
    days: int
    hours: int            # ALWAYS 8 in this simplified run
    seat_index: int
    seat_key: str         # unique key like "e1|p1o1|s0002|d12"

    # Planning variable
    employee: Annotated[Employee, PlanningVariable]

@dataclass(frozen=True)
class SeatDay:
    """Problem fact representing (seat, specific day) workload."""
    seat_key: str
    day: DaySlot
    hours: int            # ALWAYS 8 in this simplified run
    factory: str

@planning_solution
@dataclass
class Schedule:
    # value ranges
    days: Annotated[List[DaySlot], ProblemFactCollectionProperty, ValueRangeProvider]
    employees: Annotated[List[Employee], ProblemFactCollectionProperty, ValueRangeProvider]

    # problem facts
    seat_days: Annotated[List[SeatDay], ProblemFactCollectionProperty]

    # planning entities
    seats: Annotated[List[CrewSeat], PlanningEntityCollectionProperty]

    score: Annotated[HardMediumSoftScore, PlanningScore] = field(default=None)

# -------------------- Globals --------------------

_DAILY_CAP: int = 12
_TARGET_HOURS_PER_EMP: float = 0.0

# -------------------- Constraints --------------------

def _is_unassigned(emp: Optional[Employee]) -> bool:
    return (emp is None) or (emp.id == 0)

def _skill_level(emp: Optional[Employee], op_id: str) -> int:
    if emp is None:
        return 0
    skills = emp.skills
    if not isinstance(skills, dict):
        return 0
    try:
        return int(skills.get(op_id, 0))
    except Exception:
        return 0

def require_assignment_and_skill(cf: ConstraintFactory) -> Constraint:
    return (
        cf.for_each(CrewSeat)
          .filter(lambda s: _is_unassigned(s.employee) or _skill_level(s.employee, s.op_id) < 1)
          .penalize(HardMediumSoftScore.ONE_HARD)
          .as_constraint("assigned+eligible-skill")
    )

def one_factory_per_emp_day_hard(cf: ConstraintFactory) -> Constraint:
    return (
        cf.for_each(SeatDay)
          .join(cf.for_each(CrewSeat), Joiners.equal(lambda sd: sd.seat_key, lambda cs: cs.seat_key))
          .filter(lambda sd, cs: not _is_unassigned(cs.employee))
          .group_by(lambda sd, cs: (cs.employee.id, sd.day.id),
                    ConstraintCollectors.count_distinct(lambda sd, cs: sd.factory))
          .filter(lambda key, fac_cnt: fac_cnt > 1)
          .penalize(HardMediumSoftScore.ONE_HARD, lambda key, fac_cnt: fac_cnt - 1)
          .as_constraint("one-factory-per-emp-day")
    )

def daily_capacity_12h_hard(cf: ConstraintFactory) -> Constraint:
    return (
        cf.for_each(SeatDay)
          .join(cf.for_each(CrewSeat), Joiners.equal(lambda sd: sd.seat_key, lambda cs: cs.seat_key))
          .filter(lambda sd, cs: not _is_unassigned(cs.employee))
          .group_by(lambda sd, cs: (cs.employee.id, sd.day.id),
                    ConstraintCollectors.sum(lambda sd, cs: int(sd.hours)))
          .filter(lambda key, tot: tot > _DAILY_CAP)
          .penalize(HardMediumSoftScore.ONE_HARD, lambda key, tot: tot - _DAILY_CAP)
          .as_constraint("daily-cap-12h")
    )

def avoid_overtime_over8_soft(cf: ConstraintFactory) -> Constraint:
    BASE = 8
    return (
        cf.for_each(SeatDay)
          .join(cf.for_each(CrewSeat), Joiners.equal(lambda sd: sd.seat_key, lambda cs: cs.seat_key))
          .filter(lambda sd, cs: not _is_unassigned(cs.employee))
          .group_by(lambda sd, cs: (cs.employee.id, sd.day.id),
                    ConstraintCollectors.sum(lambda sd, cs: int(sd.hours)))
          .filter(lambda key, tot: tot > BASE)
          .penalize(HardMediumSoftScore.ONE_SOFT, lambda key, tot: tot - BASE)
          .as_constraint("avoid-overtime-over-8-soft")
    )

def balance_total_hours_soft(cf: ConstraintFactory) -> Constraint:
    return (
        cf.for_each(SeatDay)
          .join(cf.for_each(CrewSeat), Joiners.equal(lambda sd: sd.seat_key, lambda cs: cs.seat_key))
          .filter(lambda sd, cs: not _is_unassigned(cs.employee))
          .group_by(lambda sd, cs: cs.employee.id,
                    ConstraintCollectors.sum(lambda sd, cs: int(sd.hours)))
          .penalize(HardMediumSoftScore.ONE_SOFT,
                    lambda emp_id, tot: int(abs(int(tot) - int(_TARGET_HOURS_PER_EMP))))
          .as_constraint("balance-total-hours-soft")
    )

@constraint_provider
def define_constraints(cf: ConstraintFactory) -> List[Constraint]:
    return [
        require_assignment_and_skill(cf),
        one_factory_per_emp_day_hard(cf),
        daily_capacity_12h_hard(cf),
        avoid_overtime_over8_soft(cf),
        balance_total_hours_soft(cf),
    ]

# -------------------- YAML parsers --------------------

def _phase_num_from_id(pid: str) -> int:
    try:
        return int(str(pid).strip().lower().replace("p", ""))
    except Exception:
        return 0

def _parse_env(env_path: str):
    with open(env_path, "r", encoding="utf-8") as f:
        env = yaml.safe_load(f)["environment"]

    opdef: Dict[str, Dict] = {}
    for ph in env["workflow_list"][0]["phase_list"]:
        for op in ph["operation_list"]:
            op_id = op["id"]
            hrs = list(op.get("work_hours", []) or [])
            if not hrs:
                hrs = [8]
            opdef[op_id] = {
                "phase_id": ph["id"],
                "phase_num": _phase_num_from_id(ph["id"]),
                "allowed": list(sorted(hrs)),  # parsed but UNUSED in this simplified 8h run
                "min": int(op.get("min_worker_num", 1)),
                "max": int(op.get("max_worker_num", 999999)),
            }

    # employees
    employees: List[Employee] = [Employee(id=0, wid="__UNASSIGNED__", name="__UNASSIGNED__", skills={})]
    eid = 1
    for w in env["worker_list"]:
        wid = str(w.get("id"))
        name = w.get("name")
        skills = dict(w.get("skill_map") or {})
        employees.append(Employee(id=eid, wid=wid, name=name, skills=skills))
        eid += 1

    return opdef, employees

def _parse_schedule(env_opdef: Dict[str, Dict], sched_path: str):
    with open(sched_path, "r", encoding="utf-8") as f:
        s = yaml.safe_load(f)["schedule"]

    start_date = datetime.strptime(s["plan_range"]["start_date"], "%Y/%m/%d").date()
    end_date   = datetime.strptime(s["plan_range"]["end_date"], "%Y/%m/%d").date()
    horizon_days = (end_date - start_date).days + 1

    days: List[DaySlot] = [DaySlot(i, start_date + timedelta(days=i)) for i in range(horizon_days)]

    windows: List[TaskWindow] = []
    required_hours: Dict[Tuple[str, str], int] = {}  # (module, op_id) -> baseline hours (8h per workload day)

    for wf in s["workflow_task_list"]:
        module = wf["id"]
        fab = wf.get("fab")
        for ph_task in wf["phase_task_list"]:
            phase_id = ph_task["phase"]
            phase_num = _phase_num_from_id(phase_id)
            p_start = datetime.strptime(ph_task["start_date"], "%Y/%m/%d").date()
            p_end   = datetime.strptime(ph_task["end_date"], "%Y/%m/%d").date()
            start_id = (p_start - start_date).days
            end_id   = (p_end   - start_date).days

            for ot in ph_task["operation_task_list"]:
                op_id = ot["operation"]
                workload_days = int(ot["workload_days"])

                ocfg = env_opdef.get(op_id)
                if ocfg is None:
                    raise ValueError(f"operation {op_id} not present in EnvConfig.workflow_list")

                # allowed = ocfg["allowed"]  # <-- parsed but UNUSED in this simplified run
                min_h = ocfg["min"]; max_h = ocfg["max"]

                # *** SIMPLIFIED: required hours = workload_days * 8 (IGNORE hour options) ***
                req_hours = workload_days * 8
                required_hours[(module, op_id)] = required_hours.get((module, op_id), 0) + req_hours

                windows.append(TaskWindow(
                    module=module, factory=fab, phase_id=phase_id, phase_num=phase_num,
                    op_id=op_id, start_day_id=start_id, end_day_id=end_id,
                    allowed=list(ocfg.get("allowed", [8])),  # keep in object but not used
                    min_heads=min_h, max_heads=max_h,
                    workload_days=workload_days
                ))

    return start_date, days, windows, required_hours

# -------------------- Build blocks -> seats + seat-days (Pass 1 expansion) --------------------

def _build_blocks_with_phase_order_8h(windows: List[TaskWindow],
                                      required_hours: Dict[Tuple[str, str], int]) -> List[CrewBlock]:
    """
    For each module:
      - sort by phase_num, then by window start
      - ensure each phase starts after the previous phase (within that module) finishes
      - build exactly one 8h/day block per window, consuming that module/op's required hours
    """
    by_module: Dict[str, List[TaskWindow]] = defaultdict(list)
    for w in windows:
        by_module[w.module].append(w)

    remaining = dict(required_hours)
    blocks: List[CrewBlock] = []

    for module, win_list in by_module.items():
        win_list.sort(key=lambda w: (w.phase_num, w.start_day_id, w.end_day_id))
        phase_end_by_num: Dict[int, int] = {}
        last_end = -1

        for w in win_list:
            key = (w.module, w.op_id)
            rem = int(remaining.get(key, 0))
            if rem <= 0:
                continue

            prev_phase_end = max([phase_end_by_num.get(p, -1) for p in range(1, w.phase_num)], default=-1)
            earliest = max(last_end + 1, prev_phase_end + 1, w.start_day_id)

            block = _plan_block_for_window_8h(w, rem, earliest)
            if block is None:
                continue

            blocks.append(block)
            produced = block.days * block.hours * block.heads
            use = min(rem, produced)
            remaining[key] = rem - use

            block_end = block.start_day_id + block.days - 1
            last_end = max(last_end, block_end)
            phase_end_by_num[w.phase_num] = max(phase_end_by_num.get(w.phase_num, -1), block_end)

    return blocks

def _expand_blocks_to_seats_and_days(blocks: List[CrewBlock], days: List[DaySlot]):
    seats: List[CrewSeat] = []
    seat_days: List[SeatDay] = []
    sid = 1
    day_by_id = {d.id: d for d in days}

    for b in blocks:
        for sidx in range(b.heads):
            seat_key = f"{b.module}|{b.op_id}|s{str(sidx).zfill(4)}|d{b.start_day_id}"
            seats.append(CrewSeat(
                id=sid,
                module=b.module, factory=b.factory,
                phase_id=b.phase_id, phase_num=b.phase_num,
                op_id=b.op_id,
                start_day_id=b.start_day_id,
                days=b.days, hours=8,   # ALWAYS 8
                seat_index=sidx,
                seat_key=seat_key,
                employee=Employee(0, "__UNASSIGNED__", "__UNASSIGNED__", {})
            ))
            sid += 1
            for off in range(b.days):
                did = b.start_day_id + off
                if did in day_by_id:
                    seat_days.append(SeatDay(
                        seat_key=seat_key,
                        day=day_by_id[did],
                        hours=8,              # ALWAYS 8
                        factory=b.factory
                    ))
    return seats, seat_days

# -------------------- Auditing (preview) --------------------

def _audit_hard(schedule: Schedule) -> List[Tuple]:
    viols: List[Tuple] = []

    by_emp_day_sum = defaultdict(int)
    by_emp_day_fabs = defaultdict(set)

    emp_by_seat: Dict[str, Employee] = {}
    for s in schedule.seats:
        emp_by_seat[s.seat_key] = s.employee

    for sd in schedule.seat_days:
        emp = emp_by_seat.get(sd.seat_key)
        if _is_unassigned(emp):
            continue
        by_emp_day_sum[(emp.name, sd.day.id)] += int(sd.hours)
        by_emp_day_fabs[(emp.name, sd.day.id)].add(sd.factory)

    for (emp, did), total in by_emp_day_sum.items():
        if total > _DAILY_CAP:
            viols.append(("DAILY_CAP", emp, did, total))
    for (emp, did), facs in by_emp_day_fabs.items():
        if len(facs) > 1:
            viols.append(("FACTORY_MIX", emp, did, sorted(facs)))

    for seat in schedule.seats:
        if _is_unassigned(seat.employee):
            viols.append(("UNASSIGNED_SEAT", seat.module, seat.op_id, seat.start_day_id, seat.days))
        elif _skill_level(seat.employee, seat.op_id) < 1:
            viols.append(("SKILL", seat.employee.name, seat.op_id, seat.start_day_id))

    return viols

def _print_audit(tag: str, schedule: Schedule, elapsed_s: float | None = None):
    viols = _audit_hard(schedule)
    timing = f" | time: {elapsed_s:.2f}s" if elapsed_s is not None else ""
    print(f"\n=== {tag}: HARD VIOLATIONS ({len(viols)}){timing} ===")
    for v in viols[:20]:
        print(v)
    if len(viols) > 20:
        print(f"... ({len(viols) - 20} more)")

# -------------------- Build & 2-pass Solve --------------------

def solve_from_yaml(env_path: str = "EnvConfig.yaml", sched_path: str = "Schedule.yaml"):
    global _TARGET_HOURS_PER_EMP

    env_opdef, employees = _parse_env(env_path)
    start_day, days, windows, required_hours = _parse_schedule(env_opdef, sched_path)

    real_emp_count = max(1, len(employees) - 1)   # exclude dummy idx 0
    total_required_hours = sum(required_hours.values())
    _TARGET_HOURS_PER_EMP = total_required_hours / real_emp_count

    # -------- Pass 1: blocks (8h), enforce phase order -> seats+days --------
    blocks = _build_blocks_with_phase_order_8h(windows, required_hours)
    seats, seat_days = _expand_blocks_to_seats_and_days(blocks, days)

    base_problem = Schedule(
        days=days,
        employees=employees,
        seat_days=seat_days,
        seats=seats
    )

    # -------- Pass 2: assign employees --------
    t0 = time.time()
    solver1 = _build_solver(best_limit="0hard/*medium/*soft", spent_minutes=20, unimproved_seconds=45)
    p1s = time.time()
    after1: Schedule = solver1.solve(base_problem)
    p1e = time.time()
    _print_audit("PASS 1 (feasible)", after1, elapsed_s=(p1e - p1s))

    solver2 = _build_solver(spent_minutes=10, unimproved_seconds=45)
    p2s = time.time()
    final: Schedule = solver2.solve(after1)
    p2e = time.time()
    _print_audit("PASS 2 (polish)", final, elapsed_s=(p2e - p2s))

    print(f"\nTOTAL solving time: {p2e - t0:.2f}s "
          f"(P1 {p1e - p1s:.2f}s, P2 {p2e - p2s:.2f}s)")

    return final, start_day

def _build_solver(best_limit: str | None = None,
                  spent_minutes: int | None = None,
                  unimproved_seconds: int | None = None):
    term_kwargs = {}
    if best_limit is not None:
        term_kwargs["best_score_limit"] = best_limit
    if spent_minutes is not None:
        term_kwargs["spent_limit"] = Duration(minutes=spent_minutes)
    if unimproved_seconds is not None:
        term_kwargs["unimproved_spent_limit"] = Duration(seconds=unimproved_seconds)

    cfg = SolverConfig(
        solution_class=Schedule,
        entity_class_list=[CrewSeat],
        score_director_factory_config=ScoreDirectorFactoryConfig(
            constraint_provider_function=define_constraints
        ),
        termination_config=TerminationConfig(**term_kwargs)
    )
    return SolverFactory.create(cfg).build_solver()

def main():
    final, start_day = solve_from_yaml("EnvConfig.yaml", "Schedule.yaml")
    overwrite_schedule_with_assignments(final, start_day, "Schedule.yaml")

if __name__ == "__main__":
    main()
