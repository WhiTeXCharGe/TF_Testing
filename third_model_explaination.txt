
third_model_explaination.txt
============================

Overview
--------
This document explains the **third model** implemented in `employee_scheduler_by_capacity.py`,
also called the **capacity / team-seat model**. In this formulation:

- Each task (e.g. `P1-A`) runs during a **continuous time window** (from a computed process start
  until the task's deadline).
- The task has a fixed **team size** = `daily_max`. We create that many **TeamSeat** entities.
- The solver assigns **one employee per seat**, and that employee is considered to work on the
  task **for every day** in the task’s window.
- Processes are **sequential** (no overlap) based on deadlines/precedence.
- Soft constraints encourage a **variety of skill levels** within each task’s team and a gentle
  centering of levels near 3.

This model is ideal when you want a **stable team per task** throughout that task’s active window,
rather than moving people in/out day by day.

Domain Model
------------

1) DaySlot
   - `DaySlot(id: int, d: date)`
   - One calendar day in the planning horizon. `id` = 0 for `start_day`, 1 for next day, etc.

2) SkillKey
   - `SkillKey(process_id: int, task: str)` → canonical code via `code()` like `"P2-B"`.

3) Employee
   - `Employee(id: int, name: str, skills: Dict[str, int])`
   - Skill levels (1..5) are **task-code specific** (e.g. `"P1-A": 4`). Missing entries are treated
     as low (used only for **soft** scoring in this model; there is no hard minimum).

4) TaskWindow  (problem fact)
   - `TaskWindow(task_code, process_id, task_letter, start_day_id, end_day_id, daily_max)`
   - Describes the **active window** for a task, inclusive of both ends.
   - `start_day_id` is derived from process order; `end_day_id` is the (clamped) deadline index.
   - `daily_max` is the **team size** for this task for **all days** within the window.

5) TeamSeat  (planning entity)
   - `TeamSeat(id, task_code, process_id, task_letter, start_day_id, end_day_id, employee=None)`
   - There are exactly `daily_max` seats per task.
   - The solver assigns **one employee** per seat. That employee is considered to occupy the seat
     across the entire `[start_day_id, end_day_id]` window.
   - No per-day assignment choice is made; the seat spans the whole window by construction.

6) Schedule  (planning solution)
   - `Schedule(days, employees, windows, seats, score)`
   - `days`, `employees`, `windows` are **ProblemFactCollectionProperty** (fixed inputs).
   - `seats` is **PlanningEntityCollectionProperty** (the solver sets `seat.employee`).
   - `score` is a `HardSoftScore` produced by the constraints.

How Windows Are Built (YAML → Windows)
--------------------------------------
The loader supports your **old YAML** (no explicit process-level deadlines):

- Each task row in `tasks:` provides `code`, `daily_max`, `deadline`.
- For each **process** (P1, P2, ...), we derive a **process deadline** as the **max** of its tasks’ deadlines.
- Process order is taken from optional `precedence:`; if missing, processes are ordered ascending (P1, P2, ...).
- The **start_day_id** of the first process = 0. Each next process starts **after** the previous process
  ends: `start_{p} = end_{p-1} + 1`, where `end_p` is that process’s derived deadline index.
- A **TaskWindow** for a task uses:
  - `start_day_id = start_{process_of_task}`
  - `end_day_id   = min(task_deadline_idx, end_{process_of_task})` (clamped to horizon)

This ensures **processes do not overlap** and every task lives inside its process window.
(If precedence mentions a process with no tasks, it is ignored for window building.)

Constraint Provider
-------------------
**Hard constraints** (must be 0 for feasibility):

1) Seat must have an employee
   - Forbids unassigned seats.

2) Employee double-booked on overlapping task windows
   - If the same employee is assigned to two seats whose date ranges overlap, penalize hard.
   - This prevents an employee from being on two teams at the same time.

3) Processes must not overlap
   - For any two seats `a` (process p) and `b` (process q) with `p < q`, require `a.end < b.start`.
   - Enforces that all seats of an earlier process end before any seat of the next process starts.
   - Combined with window construction, this preserves sequential processes end-to-start.

**Soft constraints** (optimize after feasibility):

1) Prefer earlier processes (tiny)
   - Small nudge to favor lower process IDs, useful if there are ties.

2) Levels near average 3 (gentle)
   - Mildly penalizes large deviations from level 3: `penalty ≈ abs(level - 3) // 2`.
   - Keeps the team composition from being too extreme, but does not force everything to level 3.

3) Prefer diverse levels per team (strong)
   - Applies to **pairs of seats within the same task** (same team).
   - Penalizes **similar** levels more than **diverse** ones:
       * diff 0 → strong penalty
       * diff 1 → medium
       * diff 2 → light
       * diff ≥3 → none
   - Extra penalty when both are level 3 to avoid clustering at 3.
   - Encourages combinations like `1,3,5` or `2,3,4` instead of `3,3,3` or `4,4`.

What the Solver Decides
-----------------------
- For each `TeamSeat`, pick **one employee** who is not double-booked across overlapping windows.
- The chosen employee appears in the export on **every day** within that task’s window.

Exporters (Excel)
-----------------
Two useful sheets can be produced (see `export_matrix_capacity.py`):

1) **Schedule by Task** (rows = task_code, columns = dates)
   - Each cell shows the **comma-joined team members** during that day (since the team is constant,
     names are the same across the window).
   - The **deadline cell** is highlighted (light blue).

2) **Schedule by Employee** (rows = employee, columns = dates)
   - Each cell shows which **task codes** an employee works that day.
   - No color highlight by default.

When to Use This Model
----------------------
Choose the team-seat model when:
- You want **stable teams per task** throughout their active windows.
- You want processes to be **sequential** (no overlap) with windows derived from deadlines.
- You care about **level variety inside each team**, rather than scheduling person-days per date.

If instead you need **per-day assignment** (e.g., different people can rotate on different days,
or the number of person-days is driven by `workload`), use the **second model** (per-day bucket model).

Edge Cases & Feasibility
------------------------
- If there are **not enough employees** to staff all concurrent seats across processes, the solver cannot
  satisfy the hard constraints (infeasible).
- If the **derived windows** make processes overlap due to deadlines being too tight, the hard constraint
  prevents overlap and feasibility fails. Adjust deadlines or precedence.
- If some tasks have `daily_max = 0`, no seats are created for them; they effectively do not need staffing.

Tuning Suggestions
------------------
- To **favor more variety**, increase the weight of the team variety penalty or add extra penalties for duplicates.
- To **bias toward mid-level teams**, increase the “levels near 3” weight slightly.
- To **prefer earlier processes more strongly**, add a larger soft penalty on higher process IDs.

How to Run
----------
1) Prepare YAML (your legacy format is fine):
   - `start_day`, `horizon_days`
   - optional `precedence`
   - `tasks:` each with `code`, `daily_max`, `deadline` (the `workload` field is ignored in this model)
   - `employees:` names and per-task skill levels
2) Solve:
   ```bash
   python employee_scheduler_by_capacity.py -- or simply run the module’s main()
   ```
3) Export (matrix with two sheets):
   ```bash
   python export_matrix_capacity.py --config config.yaml --out schedule_matrix.xlsx
   ```

Summary
-------
- **Entity**: `TeamSeat` (one seat per task; employee occupies it for the whole window).
- **Window**: computed per process from task deadlines + precedence (sequential; no overlaps).
- **Hard rules**: seat assignment, no double-booking across overlapping windows, sequential processes.
- **Soft rules**: nudge toward earlier processes (tiny), center around level 3 (gentle), maximize level diversity within teams (strong).
- **Exports** show constant teams over the task window and per-employee daily task membership.

This capacity/team-seat model is a clean way to form consistent teams that run from process start until deadline,
while still giving you control over team composition via soft constraints.
