def process_precedence_within_module(cf: ConstraintFactory) -> List[Constraint]:
    """
    Enforce per-module process order: (p+1) must be strictly later than p.
    Works across both token types (UnitToken4 and UnitToken8).
    """

    def pair(name_suffix, LeftCls, RightCls) -> Constraint:
        return (
            cf.for_each(LeftCls)
            .filter(lambda a: a.day is not None and a.day.id >= 0)
            .join(
                cf.for_each(RightCls).filter(lambda b: b.day is not None and b.day.id >= 0),
                # same module
                Joiners.equal(lambda a: a.module,      lambda b: b.module),
                # consecutive processes
                Joiners.equal(lambda a: a.process_id + 1, lambda b: b.process_id)
            )
            # violation if next process day is not strictly later
            .filter(lambda a, b: not (b.day.id > a.day.id))
            .penalize(HardSoftScore.ONE_HARD)
            .as_constraint(f"process-precedence-per-module {name_suffix}")
        )

    return [
        pair("[4→4]", UnitToken4, UnitToken4),
        pair("[8→8]", UnitToken8, UnitToken8),
        pair("[4→8]", UnitToken4, UnitToken8),
        pair("[8→4]", UnitToken8, UnitToken4),
    ]

@constraint_provider
def define_constraints(cf: ConstraintFactory) -> List[Constraint]:
    constraints: List[Constraint] = [
        require_assignment_and_skill(cf),
        enforce_hours_domain_per_task(cf),   # if you kept it; otherwise remove
        within_window(cf),
        daily_capacity_hard(cf),
        single_factory_per_emp_day_hard(cf),
        staffing_minmax_heads_hard(cf),
        task_hours_equality_hard(cf),

        snap_into_window_soft(cf),
        avoid_overtime_soft(cf),
        finish_earlier_soft(cf),
        balance_total_hours_soft(cf),
    ]

    # add all 4 precedence constraints
    constraints += process_precedence_within_module(cf)

    return constraints
