Short answer: with a single hours PlanningVariable that references one global range (hoursRange), you can’t make its domain differ per token at build time. In Timefold/Constraint Streams, per-entity value ranges require either:

separate entity classes with different value range providers, or

keep one entity and enforce the domain by a constraint (what you’re doing now).

Since you want to control hours at build time (no constraint), the clean way is two entity types: one whose hours can only be 4, and one whose hours can be [4,8,10,12]. Below are the minimal changes; all existing function names stay the same.

What to change
1) Add a fixed-value hours range for 4-hour tokens

Add a provider for [4] and keep your existing provider for the regular options.

# In Schedule (or near your existing value providers)
@planning_solution
@dataclass
class Schedule:
    ...
    hours_options: Annotated[
        List[int],
        ProblemFactCollectionProperty,
        ValueRangeProvider(id="hoursRange8")       # for 8u tokens
    ]
    hours_fixed4: Annotated[
        List[int],
        ProblemFactCollectionProperty,
        ValueRangeProvider(id="hoursRange4")       # for 4u tokens (always [4])
    ] = field(default_factory=lambda: [4])
    ...


When you build the Schedule instance, pass hours_options as today; hours_fixed4 defaults to [4] so you don’t need to touch the builder.

2) Split the entity class into two, each with its own hours range

Keep the same fields; only the hours PlanningVariable references change.

from typing import Optional

@dataclass
class _UnitTokenBase:
    id: Annotated[int, PlanningId]
    module: str
    factory: str
    process_id: int
    task_letter: str
    start_day_id: int
    end_day_id: int
    unit_hours: int
    employee: Annotated[Employee, PlanningVariable(value_range_provider_refs=["employeeRange"])]
    day: Annotated[DaySlot, PlanningVariable(value_range_provider_refs=["dayRange"])]

    def pcode(self) -> str: return f"P{self.process_id}-{self.task_letter}"
    def tcode(self) -> str: return f"{self.module}-P{self.process_id}-{self.task_letter}"

@planning_entity
@dataclass
class UnitToken4(_UnitTokenBase):
    hours: Annotated[int, PlanningVariable(value_range_provider_refs=["hoursRange4"])] = 4

@planning_entity
@dataclass
class UnitToken8(_UnitTokenBase):
    hours: Annotated[int, PlanningVariable(value_range_provider_refs=["hoursRange8"])] = 8

3) Keep both collections in the solution
@planning_solution
@dataclass
class Schedule:
    ...
    tokens4: Annotated[List[UnitToken4], PlanningEntityCollectionProperty]
    tokens8: Annotated[List[UnitToken8], PlanningEntityCollectionProperty]
    score: Annotated[HardSoftScore, PlanningScore] = field(default=None)

4) Build tokens into the right list (no constraint needed now)

Replace your build_tokens(...) and the spot where you put them on Schedule:

def build_tokens(windows, employees, days):
    dummy_emp = employees[0]
    dummy_day = days[0]
    t4: List[UnitToken4] = []
    t8: List[UnitToken8] = []
    tid = 1
    for w in windows:
        for _ in range(max(0, int(w.workload_units))):
            if w.unit_hours == 4:
                t4.append(UnitToken4(
                    id=tid, module=w.module, factory=w.factory,
                    process_id=w.process_id, task_letter=w.task_letter,
                    start_day_id=w.start_day_id, end_day_id=w.end_day_id,
                    unit_hours=w.unit_hours, employee=dummy_emp, day=dummy_day, hours=4
                ))
            else:
                t8.append(UnitToken8(
                    id=tid, module=w.module, factory=w.factory,
                    process_id=w.process_id, task_letter=w.task_letter,
                    start_day_id=w.start_day_id, end_day_id=w.end_day_id,
                    unit_hours=w.unit_hours, employee=dummy_emp, day=dummy_day, hours=8
                ))
            tid += 1
    return t4, t8


And in solve_from_config(...):

tokens4, tokens8 = build_tokens(windows, employees, days)
problem = Schedule(
    days=days,
    employees=employees,
    hours_options=hours_options,   # goes to hoursRange8
    tokens4=tokens4,
    tokens8=tokens8
)

5) Remove enforce_hours_domain_per_task constraint

It’s no longer needed. Delete it from define_constraints(...) and the function.

6) Update constraints to iterate over both entity types

Where you had cf.for_each(UnitToken), just do the same logic twice—once for UnitToken4 and once for UnitToken8. Give the twin constraints distinct names. Example for within_window:

def within_window(cf: ConstraintFactory) -> Constraint:
    c4 = (
        cf.for_each(UnitToken4)
        .filter(lambda u: (u.day is None) or (u.day.id < 0) or (u.day.id < u.start_day_id) or (u.day.id > u.end_day_id))
        .penalize(HardSoftScore.ONE_HARD)
        .as_constraint("within-window [4u]")
    )
    c8 = (
        cf.for_each(UnitToken8)
        .filter(lambda u: (u.day is None) or (u.day.id < 0) or (u.day.id < u.start_day_id) or (u.day.id > u.end_day_id))
        .penalize(HardSoftScore.ONE_HARD)
        .as_constraint("within-window [8u]")
    )
    # Return both; caller (Timefold) accepts a list from @constraint_provider
    return [c4, c8]


For constraints that group or join, repeat the same pattern on each type and/or across both types where needed:

Per-employee/day sums (capacity, overtime): create one constraint for UnitToken4, one for UnitToken8. They can share the same name suffixes [...] for clarity.

If you need cross-type joins (e.g., process precedence pairs), write three constraints:

UnitToken4↔UnitToken4

UnitToken8↔UnitToken8

UnitToken4↔UnitToken8 (and the symmetric if needed)

It’s a few more lines, but mechanically straightforward and avoids any hours-domain constraint.

Why this works

Each entity class binds its hours to a different value range provider.

The solver will never propose an illegal hour for 4-hour tokens, because the domain is literally [4].

Later, if you want “factory B: allowed hours = [4, 8, 12] (no 10)”, you can add a UnitToken8_BOnly (or generalize by factory) with its own range provider, and route tokens there in build_tokens(...)—still no constraints needed.
