
second_model_explaination.txt
=============================

Overview
--------
This document explains the **second model** used in `employee_scheduler.py`, which schedules
employees to tasks across a calendar, using **person-day work units** and explicit **per-day
capacity buckets**. The model is built with **Timefold Solver for Python** and uses
constraint streams to enforce hard feasibility rules and optimize soft preferences.

Core Idea
---------
We transform your planning problem into many small "decisions":
- Each **RequirementSlot** represents **one person-day** of work for a specific task (e.g. P1-A).
- Each calendar day and task has a limited number of **TaskDayBucket** objects, implementing
  **per-day capacity** (e.g. daily_max = 2 → we create 2 buckets for that task for each day).
- The solver **assigns** both:
  1) **WHO** works (an Employee); and
  2) **WHEN** (which bucket/day).
- Constraints ensure no capacity overflow, no double-booking, deadlines are met, and
  processes follow the specified order. Soft constraints encourage nice-to-have patterns
  such as earlier scheduling and skill-level variety on the same task-day.

Domain Model
------------

1) DaySlot
   - `DaySlot(id: int, d: date)`
   - Represents one calendar day in the planning horizon.
   - `id` is an index starting at 0 (start_day + id days).

2) SkillKey
   - `SkillKey(process_id: int, task: str)`
   - Identifies a task with a process number (e.g. 1..N) and a letter (A..Z).
   - `code()` returns a canonical "P{process}-{task}" code, e.g. "P2-B".

3) Employee
   - `Employee(id: int, name: str, skills: Dict[str, int])`
   - Each employee can have a skill level (1..5) **per task code** (e.g. "P1-A": 4).
   - Missing entries default to low level in soft scoring (for diversity), not as a hard ban.

4) TaskDayBucket  (capacity carrier)
   - `TaskDayBucket(id: int, task_code: str, day: DaySlot)`
   - A bucket is **one seat** of capacity for a given task on a given day.
   - If a task has `daily_max = 3`, we create **3 buckets per day** for that task.
   - **At most one RequirementSlot may occupy a bucket** (enforced by a hard constraint).

5) RequirementSlot  (planning entity)
   - `RequirementSlot(id, skill, deadline_day_id, employee=None, bucket=None)`
   - **Planning entity**: the solver is allowed to set `employee` and `bucket`.
   - Interpreted as **one person-day of work** for a specific task (`skill`).
   - `deadline_day_id` is the latest allowable day index (0-based from start) for scheduling.
   - Variables to decide:
       - `employee`: which employee does this person-day.
       - `bucket`: which per-day capacity bucket (implicitly decides the day via `bucket.day`).

6) Schedule  (planning solution)
   - Contains problem facts and entities:
     - `days: List[DaySlot]` (facts, value range for `bucket.day` through `buckets`)
     - `employees: List[Employee]` (facts, value range for `employee`)
     - `buckets: List[TaskDayBucket]` (facts, value range for `bucket`)
     - `reqs: List[RequirementSlot]` (planning entities)
     - `score: HardSoftScore` (computed by constraints)

Value Ranges and Assignments
----------------------------
- **ValueRangeProvider** on facts exposes allowed values to planning variables:
  - `RequirementSlot.employee` draws from `employees`.
  - `RequirementSlot.bucket` draws from `buckets`.
- Choosing a `bucket` also sets the **date** for that slot via `bucket.day`.
- Capacity is **naturally limited** because there is exactly one RequirementSlot allowed per bucket.

YAML → Problem Build
--------------------
Your YAML defines:
- `start_day` and `horizon_days`: create `DaySlot`s.
- `tasks`: each with `code`, `workload` (person-days total), `daily_max` (per-day capacity),
  and a **task-specific `deadline`**.
- `employees`: names and **per-task skill levels** (1..5).

Two helper builders construct the planning data:
1) `build_buckets(tasks, days)`:
   - For every task code and for **every day** in the horizon,
     create `daily_max` **TaskDayBucket**s.
   - Example: if `daily_max=2` for P1-A, and we have 14 days, we create `2 × 14` buckets for P1-A.

2) `build_requirement_slots(tasks)`:
   - For each task, create `workload` **RequirementSlot**s (one per person-day required).
   - Each slot knows its `skill` (task code) and its `deadline_day_id` (date → day index).

Constraint Provider
-------------------
Constraints are split into **HARD** (must be satisfied) and **SOFT** (preferences).

HARD constraints
----------------
1) **Employee must be assigned**
   - Forbids leaving a RequirementSlot without an employee.
   - `filter(r.employee is None)` → penalize hard.

2) **Bucket (task-day) must be assigned**
   - Forbids leaving a RequirementSlot without a bucket (so without a day).
   - `filter(r.bucket is None)` → penalize hard.

3) **Bucket task mismatch**
   - A RequirementSlot for task code `X` must be placed in a bucket with the **same** task code `X`.
   - Prevents “P1-A work” from being scheduled into a “P2-C bucket”.

4) **Bucket capacity exceeded**
   - Unique pair on `bucket`; if two RequirementSlots choose the **same** bucket → penalize hard.
   - Enforces **max 1 person-day per bucket** → respects `daily_max` overall.

5) **Employee double-booked same day**
   - Unique pair on `(employee, bucket.day)`; if the same employee appears twice on the same day → penalize hard.
   - Prevents an employee from working two different slots on a single day.

6) **Deadline violated**
   - If the slot’s chosen day (via `bucket.day.id`) is after `deadline_day_id`, penalize hard.
   - Ensures every task’s person-days finish **on or before** its deadline.

7) **Process precedence increasing by day**
   - For any pair `(a, b)` where `a.skill.process_id < b.skill.process_id`, require that `b` is scheduled to a **strictly later day** than `a`.
   - This effectively enforces **P1 finishes before P2 starts**, P2 before P3, etc.
   - Implemented with `for_each_unique_pair(..., Joiners.less_than(lambda r: r.skill.process_id)).filter(violates)`
     comparing days via `bucket.day.id`.

SOFT constraints
----------------
1) **Prefer earlier days**
   - Penalizes later day indices; nudges the solver to fill earlier dates first.
   - This is optional but helps to compact schedules.

2) **Levels near average 3 (gentle)**
   - Mildly penalizes big deviations from level 3, encouraging balanced skill usage without forbidding extremes.
   - Cost ~ `abs(level - 3) // 2`. It’s a **gentle** preference, not a hard rule.

3) **Prefer diverse levels per task-day**
   - Looks at **pairs of slots** on the **same (task, day)** and penalizes **similar** levels more than **diverse** levels.
   - Penalty by closeness: 0-diff is strongest, 1-diff medium, 2-diff light, ≥3-diff zero.
   - Extra penalty if both are level 3 (to avoid clustering at 3).
   - This encourages distributions like `1,3,5` or `2,3,4` rather than `3,3,3` or `4,4` on the same task-day.

What the Solver Optimizes
-------------------------
1) **Feasibility first**: zero hard penalties (no double-booking, capacity respected, deadlines met, precedence obeyed, all slots & buckets assigned).
2) **Quality next** (soft score): earlier packing, balanced levels around 3, and level variety within the same task-day.

Common Edge Cases
-----------------
- **Insufficient capacity before a deadline**: If total `workload` for a task exceeds the total buckets available up to its deadline,
  the solver cannot place everything on time → hard score becomes negative. Fix by extending the deadline, increasing `daily_max`,
  or reducing `workload`.
- **Too few employees**: If there are fewer people than the sum of parallel slots on a day (across tasks), hard infeasibility occurs.
- **Process chain + late deadlines**: If P1 deadlines are late but P2 deadlines are early, precedence may force infeasibility. Align
  deadlines or adjust precedence to reflect reality.
- **Missing skill entries**: Missing levels default to low for soft constraints only (diversity/centering). There is **no hard skill
  requirement** in this model unless you add one.

Tuning Tips
-----------
- If you want **stronger variety**, increase the pair penalty weight (e.g., multiply by 3 or add an additional penalty for duplicate levels).
- If you want **earliest finish** to dominate, increase the soft penalty per day index.
- If you want to **discourage overqualification**, reintroduce a soft penalty for (employee_level - desired_level), if you later add
  desired levels per task.
- If you want **strict fixed team per task per day** (same people every day), switch to the "capacity/team-seat" model (3rd model)
  where each seat is assigned one employee across the entire window, then exported over all days.

How Exporters Consume the Solution
----------------------------------
- **By-task sheet (matrix)**:
  - Build a grid: rows = task code, columns = dates.
  - For each RequirementSlot with (employee, bucket.day), append employee name to cell[(task_code, date)].
  - Highlight the deadline cell for that task.

- **By-employee sheet (matrix)**:
  - Build a grid: rows = employee, columns = dates.
  - For each RequirementSlot with (employee, bucket.day), insert the task code into cell[(employee, date)].
  - No highlight needed here.

When to Prefer the Second Model
-------------------------------
Use this model when:
- You want to **drive capacity by the combination of workload + daily_max**.
- You want the solver to decide **both which day** and **which person** for each person-day unit.
- You want **within-day diversity** of skill levels on the same task.
- Your tasks can be split across multiple days/capacity buckets up to a deadline.

If you instead want **the same team to work every day across a window** (e.g., from process start until deadline),
use the **capacity/team-seat model** where each seat is assigned a single employee and the exporter prints that same team
on every active day.

Summary
-------
- **Entity** = RequirementSlot (one person-day of a task), solver picks (employee, bucket).
- **Bucket** = one seat of capacity for (task, day) → ensures per-day limits.
- **Solution** = all inputs (days, employees, buckets) + all RequirementSlots + the computed score.
- **Hard rules** ensure feasibility (assignment, capacity, no double-booking, deadlines, precedence).
- **Soft rules** shape quality (earliness, balance around level 3, diversity within a task-day).
- The model matches a granular “fill capacity by person-day” scheduling style while giving you levers to steer
  the distribution of skill levels across the plan.
